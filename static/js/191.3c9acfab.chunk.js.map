{"version":3,"sources":["../node_modules/blueimp-load-image/js/load-image.js","../node_modules/blueimp-load-image/js/load-image-meta.js","../node_modules/blueimp-load-image/js/load-image-scale.js","../node_modules/blueimp-load-image/js/load-image-exif.js","../node_modules/blueimp-load-image/js/load-image-iptc.js","../node_modules/blueimp-load-image/js/load-image-fetch.js","../node_modules/blueimp-load-image/js/load-image-exif-map.js","../node_modules/blueimp-load-image/js/load-image-iptc-map.js","../node_modules/blueimp-load-image/js/load-image-orientation.js","../node_modules/blueimp-load-image/js/index.js"],"names":["__WEBPACK_AMD_DEFINE_RESULT__","$","loadImage","file","callback","options","url","img","document","createElement","onerror","event","onload","fetchBlob","blob","createObjectURL","crossOrigin","src","isInstanceOf","_objectURL","readFile","e","target","result","urlAPI","URL","revokeObjectURL","webkitURL","revokeHelper","noRevoke","type","obj","Object","prototype","toString","call","transform","data","originalWidth","naturalWidth","width","originalHeight","naturalHeight","height","method","FileReader","fileReader","undefined","exports","__webpack_require__","module","window","this","__WEBPACK_AMD_DEFINE_FACTORY__","__WEBPACK_AMD_DEFINE_ARRAY__","factory","hasblobSlice","Blob","slice","webkitSlice","mozSlice","blobSlice","apply","arguments","metaDataParsers","jpeg","65505","65517","parseMetaData","that","maxMetaDataSize","noMetaData","DataView","size","error","console","log","markerBytes","markerLength","parsers","i","buffer","dataView","offset","maxOffset","byteLength","headLength","getUint16","length","disableImageHead","imageHead","Uint8Array","subarray","hasMetaOption","meta","originalTransform","scale","transformCoordinates","getTransformedOptions","newOptions","aspectRatio","hasOwnProperty","crop","maxWidth","maxHeight","renderImageToCanvas","canvas","sourceX","sourceY","sourceWidth","sourceHeight","destX","destY","destWidth","destHeight","getContext","drawImage","hasCanvasOption","minWidth","minHeight","pixelRatio","downsamplingRatio","tmp","useCanvas","scaleUp","Math","max","scaleDown","min","left","top","right","bottom","contain","cover","style","ExifMap","map","Orientation","get","id","getExifThumbnail","exifTagTypes","1","getValue","dataOffset","getUint8","2","String","fromCharCode","ascii","3","littleEndian","4","getUint32","5","9","getInt32","10","getExifValue","tiffOffset","tagSize","values","str","c","tagType","parseExifTag","tag","exif","parseExifTags","dirOffset","tagsNumber","dirEndOffset","parseExifData","disableExif","thumbnailData","disableExifThumbnail","Thumbnail","disableExifSub","disableExifGps","push","IptcMap","ObjectName","parseIptcTags","startOffset","sectionLength","getStringFromDB","start","outstr","n","fieldValue","dataSize","segmentType","segmentStartPos","iptc","tags","getInt16","Array","parseIptcData","disableIptc","isFieldSegmentStart","nameHeaderLength","fetch","Request","then","response","catch","err","256","257","34665","34853","40965","258","259","262","274","277","284","530","531","282","283","296","273","278","279","513","514","301","318","319","529","532","306","270","271","272","305","315","33432","36864","40960","40961","40962","40963","42240","37121","37122","37500","37510","40964","36867","36868","37520","37521","37522","33434","33437","34850","34852","34855","34856","34864","34865","34866","34867","34868","34869","37377","37378","37379","37380","37381","37382","37383","37384","37385","37396","37386","41483","41484","41486","41487","41488","41492","41493","41495","41728","41729","41730","41985","41986","41987","41988","41989","41990","41991","41992","41993","41994","41995","41996","42016","42032","42033","42034","42035","42036","42037","0","6","7","8","11","12","13","14","15","16","17","18","19","20","21","22","23","24","25","26","27","28","29","30","31","stringValues","ExposureProgram","MeteringMode","255","LightSource","Flash","32","65","69","71","73","77","79","89","93","95","SensingMethod","SceneCaptureType","SceneType","CustomRendered","WhiteBalance","GainControl","Contrast","Saturation","Sharpness","SubjectDistanceRange","FileSource","ComponentsConfiguration","getText","value","exifMapPrototype","prop","getAll","35","37","38","40","42","45","47","50","55","60","62","63","70","75","80","85","90","92","100","101","103","105","110","115","116","118","120","122","130","131","135","iptcMapPrototype","originalHasCanvasOption","originalHasMetaOption","originalTransformCoordinates","originalGetTransformedOptions","orientation","ctx","styleWidth","styleHeight","translate","rotate","PI","opts"],"mappings":"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","file":"static/js/191.3c9acfab.chunk.js","sourcesContent":["/*\n * JavaScript Load Image\n * https://github.com/blueimp/JavaScript-Load-Image\n *\n * Copyright 2011, Sebastian Tschan\n * https://blueimp.net\n *\n * Licensed under the MIT license:\n * https://opensource.org/licenses/MIT\n */\n\n/* global define, URL, webkitURL, FileReader */\n;\n\n(function ($) {\n  'use strict'; // Loads an image for a given File object.\n  // Invokes the callback with an img or optional canvas\n  // element (if supported by the browser) as parameter:\n\n  function loadImage(file, callback, options) {\n    var img = document.createElement('img');\n    var url;\n\n    img.onerror = function (event) {\n      return loadImage.onerror(img, event, file, callback, options);\n    };\n\n    img.onload = function (event) {\n      return loadImage.onload(img, event, file, callback, options);\n    };\n\n    if (typeof file === 'string') {\n      loadImage.fetchBlob(file, function (blob) {\n        if (blob) {\n          file = blob;\n          url = loadImage.createObjectURL(file);\n        } else {\n          url = file;\n\n          if (options && options.crossOrigin) {\n            img.crossOrigin = options.crossOrigin;\n          }\n        }\n\n        img.src = url;\n      }, options);\n      return img;\n    } else if (loadImage.isInstanceOf('Blob', file) || // Files are also Blob instances, but some browsers\n    // (Firefox 3.6) support the File API but not Blobs:\n    loadImage.isInstanceOf('File', file)) {\n      url = img._objectURL = loadImage.createObjectURL(file);\n\n      if (url) {\n        img.src = url;\n        return img;\n      }\n\n      return loadImage.readFile(file, function (e) {\n        var target = e.target;\n\n        if (target && target.result) {\n          img.src = target.result;\n        } else if (callback) {\n          callback(e);\n        }\n      });\n    }\n  } // The check for URL.revokeObjectURL fixes an issue with Opera 12,\n  // which provides URL.createObjectURL but doesn't properly implement it:\n\n\n  var urlAPI = $.createObjectURL && $ || $.URL && URL.revokeObjectURL && URL || $.webkitURL && webkitURL;\n\n  function revokeHelper(img, options) {\n    if (img._objectURL && !(options && options.noRevoke)) {\n      loadImage.revokeObjectURL(img._objectURL);\n      delete img._objectURL;\n    }\n  } // If the callback given to this function returns a blob, it is used as image\n  // source instead of the original url and overrides the file argument used in\n  // the onload and onerror event callbacks:\n\n\n  loadImage.fetchBlob = function (url, callback, options) {\n    callback();\n  };\n\n  loadImage.isInstanceOf = function (type, obj) {\n    // Cross-frame instanceof check\n    return Object.prototype.toString.call(obj) === '[object ' + type + ']';\n  };\n\n  loadImage.transform = function (img, options, callback, file, data) {\n    callback(img, data);\n  };\n\n  loadImage.onerror = function (img, event, file, callback, options) {\n    revokeHelper(img, options);\n\n    if (callback) {\n      callback.call(img, event);\n    }\n  };\n\n  loadImage.onload = function (img, event, file, callback, options) {\n    revokeHelper(img, options);\n\n    if (callback) {\n      loadImage.transform(img, options, callback, file, {\n        originalWidth: img.naturalWidth || img.width,\n        originalHeight: img.naturalHeight || img.height\n      });\n    }\n  };\n\n  loadImage.createObjectURL = function (file) {\n    return urlAPI ? urlAPI.createObjectURL(file) : false;\n  };\n\n  loadImage.revokeObjectURL = function (url) {\n    return urlAPI ? urlAPI.revokeObjectURL(url) : false;\n  }; // Loads a given File object via FileReader interface,\n  // invokes the callback with the event object (load or error).\n  // The result can be read via event.target.result:\n\n\n  loadImage.readFile = function (file, callback, method) {\n    if ($.FileReader) {\n      var fileReader = new FileReader();\n      fileReader.onload = fileReader.onerror = callback;\n      method = method || 'readAsDataURL';\n\n      if (fileReader[method]) {\n        fileReader[method](file);\n        return fileReader;\n      }\n    }\n\n    return false;\n  };\n\n  if (typeof define === 'function' && define.amd) {\n    define(function () {\n      return loadImage;\n    });\n  } else if (typeof module === 'object' && module.exports) {\n    module.exports = loadImage;\n  } else {\n    $.loadImage = loadImage;\n  }\n})(typeof window !== 'undefined' && window || this);","/*\n * JavaScript Load Image Meta\n * https://github.com/blueimp/JavaScript-Load-Image\n *\n * Copyright 2013, Sebastian Tschan\n * https://blueimp.net\n *\n * Image meta data handling implementation\n * based on the help and contribution of\n * Achim StÃ¶hr.\n *\n * Licensed under the MIT license:\n * https://opensource.org/licenses/MIT\n */\n\n/* global define, Blob */\n;\n\n(function (factory) {\n  'use strict';\n\n  if (typeof define === 'function' && define.amd) {\n    // Register as an anonymous AMD module:\n    define(['./load-image'], factory);\n  } else if (typeof module === 'object' && module.exports) {\n    factory(require('./load-image'));\n  } else {\n    // Browser globals:\n    factory(window.loadImage);\n  }\n})(function (loadImage) {\n  'use strict';\n\n  var hasblobSlice = typeof Blob !== 'undefined' && (Blob.prototype.slice || Blob.prototype.webkitSlice || Blob.prototype.mozSlice);\n\n  loadImage.blobSlice = hasblobSlice && function () {\n    var slice = this.slice || this.webkitSlice || this.mozSlice;\n    return slice.apply(this, arguments);\n  };\n\n  loadImage.metaDataParsers = {\n    jpeg: {\n      0xffe1: [],\n      // APP1 marker\n      0xffed: [] // APP13 marker\n\n    } // Parses image meta data and calls the callback with an object argument\n    // with the following properties:\n    // * imageHead: The complete image head as ArrayBuffer (Uint8Array for IE10)\n    // The options argument accepts an object and supports the following\n    // properties:\n    // * maxMetaDataSize: Defines the maximum number of bytes to parse.\n    // * disableImageHead: Disables creating the imageHead property.\n\n  };\n\n  loadImage.parseMetaData = function (file, callback, options, data) {\n    options = options || {};\n    data = data || {};\n    var that = this; // 256 KiB should contain all EXIF/ICC/IPTC segments:\n\n    var maxMetaDataSize = options.maxMetaDataSize || 262144;\n    var noMetaData = !(typeof DataView !== 'undefined' && file && file.size >= 12 && file.type === 'image/jpeg' && loadImage.blobSlice);\n\n    if (noMetaData || !loadImage.readFile(loadImage.blobSlice.call(file, 0, maxMetaDataSize), function (e) {\n      if (e.target.error) {\n        // FileReader error\n        console.log(e.target.error);\n        callback(data);\n        return;\n      } // Note on endianness:\n      // Since the marker and length bytes in JPEG files are always\n      // stored in big endian order, we can leave the endian parameter\n      // of the DataView methods undefined, defaulting to big endian.\n\n\n      var buffer = e.target.result;\n      var dataView = new DataView(buffer);\n      var offset = 2;\n      var maxOffset = dataView.byteLength - 4;\n      var headLength = offset;\n      var markerBytes;\n      var markerLength;\n      var parsers;\n      var i; // Check for the JPEG marker (0xffd8):\n\n      if (dataView.getUint16(0) === 0xffd8) {\n        while (offset < maxOffset) {\n          markerBytes = dataView.getUint16(offset); // Search for APPn (0xffeN) and COM (0xfffe) markers,\n          // which contain application-specific meta-data like\n          // Exif, ICC and IPTC data and text comments:\n\n          if (markerBytes >= 0xffe0 && markerBytes <= 0xffef || markerBytes === 0xfffe) {\n            // The marker bytes (2) are always followed by\n            // the length bytes (2), indicating the length of the\n            // marker segment, which includes the length bytes,\n            // but not the marker bytes, so we add 2:\n            markerLength = dataView.getUint16(offset + 2) + 2;\n\n            if (offset + markerLength > dataView.byteLength) {\n              console.log('Invalid meta data: Invalid segment size.');\n              break;\n            }\n\n            parsers = loadImage.metaDataParsers.jpeg[markerBytes];\n\n            if (parsers) {\n              for (i = 0; i < parsers.length; i += 1) {\n                parsers[i].call(that, dataView, offset, markerLength, data, options);\n              }\n            }\n\n            offset += markerLength;\n            headLength = offset;\n          } else {\n            // Not an APPn or COM marker, probably safe to\n            // assume that this is the end of the meta data\n            break;\n          }\n        } // Meta length must be longer than JPEG marker (2)\n        // plus APPn marker (2), followed by length bytes (2):\n\n\n        if (!options.disableImageHead && headLength > 6) {\n          if (buffer.slice) {\n            data.imageHead = buffer.slice(0, headLength);\n          } else {\n            // Workaround for IE10, which does not yet\n            // support ArrayBuffer.slice:\n            data.imageHead = new Uint8Array(buffer).subarray(0, headLength);\n          }\n        }\n      } else {\n        console.log('Invalid JPEG file: Missing JPEG marker.');\n      }\n\n      callback(data);\n    }, 'readAsArrayBuffer')) {\n      callback(data);\n    }\n  }; // Determines if meta data should be loaded automatically:\n\n\n  loadImage.hasMetaOption = function (options) {\n    return options && options.meta;\n  };\n\n  var originalTransform = loadImage.transform;\n\n  loadImage.transform = function (img, options, callback, file, data) {\n    if (loadImage.hasMetaOption(options)) {\n      loadImage.parseMetaData(file, function (data) {\n        originalTransform.call(loadImage, img, options, callback, file, data);\n      }, options, data);\n    } else {\n      originalTransform.apply(loadImage, arguments);\n    }\n  };\n});","/*\n * JavaScript Load Image Scaling\n * https://github.com/blueimp/JavaScript-Load-Image\n *\n * Copyright 2011, Sebastian Tschan\n * https://blueimp.net\n *\n * Licensed under the MIT license:\n * https://opensource.org/licenses/MIT\n */\n\n/* global define */\n;\n\n(function (factory) {\n  'use strict';\n\n  if (typeof define === 'function' && define.amd) {\n    // Register as an anonymous AMD module:\n    define(['./load-image'], factory);\n  } else if (typeof module === 'object' && module.exports) {\n    factory(require('./load-image'));\n  } else {\n    // Browser globals:\n    factory(window.loadImage);\n  }\n})(function (loadImage) {\n  'use strict';\n\n  var originalTransform = loadImage.transform;\n\n  loadImage.transform = function (img, options, callback, file, data) {\n    originalTransform.call(loadImage, loadImage.scale(img, options, data), options, callback, file, data);\n  }; // Transform image coordinates, allows to override e.g.\n  // the canvas orientation based on the orientation option,\n  // gets canvas, options passed as arguments:\n\n\n  loadImage.transformCoordinates = function () {}; // Returns transformed options, allows to override e.g.\n  // maxWidth, maxHeight and crop options based on the aspectRatio.\n  // gets img, options passed as arguments:\n\n\n  loadImage.getTransformedOptions = function (img, options) {\n    var aspectRatio = options.aspectRatio;\n    var newOptions;\n    var i;\n    var width;\n    var height;\n\n    if (!aspectRatio) {\n      return options;\n    }\n\n    newOptions = {};\n\n    for (i in options) {\n      if (options.hasOwnProperty(i)) {\n        newOptions[i] = options[i];\n      }\n    }\n\n    newOptions.crop = true;\n    width = img.naturalWidth || img.width;\n    height = img.naturalHeight || img.height;\n\n    if (width / height > aspectRatio) {\n      newOptions.maxWidth = height * aspectRatio;\n      newOptions.maxHeight = height;\n    } else {\n      newOptions.maxWidth = width;\n      newOptions.maxHeight = width / aspectRatio;\n    }\n\n    return newOptions;\n  }; // Canvas render method, allows to implement a different rendering algorithm:\n\n\n  loadImage.renderImageToCanvas = function (canvas, img, sourceX, sourceY, sourceWidth, sourceHeight, destX, destY, destWidth, destHeight) {\n    canvas.getContext('2d').drawImage(img, sourceX, sourceY, sourceWidth, sourceHeight, destX, destY, destWidth, destHeight);\n    return canvas;\n  }; // Determines if the target image should be a canvas element:\n\n\n  loadImage.hasCanvasOption = function (options) {\n    return options.canvas || options.crop || !!options.aspectRatio;\n  }; // Scales and/or crops the given image (img or canvas HTML element)\n  // using the given options.\n  // Returns a canvas object if the browser supports canvas\n  // and the hasCanvasOption method returns true or a canvas\n  // object is passed as image, else the scaled image:\n\n\n  loadImage.scale = function (img, options, data) {\n    options = options || {};\n    var canvas = document.createElement('canvas');\n    var useCanvas = img.getContext || loadImage.hasCanvasOption(options) && canvas.getContext;\n    var width = img.naturalWidth || img.width;\n    var height = img.naturalHeight || img.height;\n    var destWidth = width;\n    var destHeight = height;\n    var maxWidth;\n    var maxHeight;\n    var minWidth;\n    var minHeight;\n    var sourceWidth;\n    var sourceHeight;\n    var sourceX;\n    var sourceY;\n    var pixelRatio;\n    var downsamplingRatio;\n    var tmp;\n\n    function scaleUp() {\n      var scale = Math.max((minWidth || destWidth) / destWidth, (minHeight || destHeight) / destHeight);\n\n      if (scale > 1) {\n        destWidth *= scale;\n        destHeight *= scale;\n      }\n    }\n\n    function scaleDown() {\n      var scale = Math.min((maxWidth || destWidth) / destWidth, (maxHeight || destHeight) / destHeight);\n\n      if (scale < 1) {\n        destWidth *= scale;\n        destHeight *= scale;\n      }\n    }\n\n    if (useCanvas) {\n      options = loadImage.getTransformedOptions(img, options, data);\n      sourceX = options.left || 0;\n      sourceY = options.top || 0;\n\n      if (options.sourceWidth) {\n        sourceWidth = options.sourceWidth;\n\n        if (options.right !== undefined && options.left === undefined) {\n          sourceX = width - sourceWidth - options.right;\n        }\n      } else {\n        sourceWidth = width - sourceX - (options.right || 0);\n      }\n\n      if (options.sourceHeight) {\n        sourceHeight = options.sourceHeight;\n\n        if (options.bottom !== undefined && options.top === undefined) {\n          sourceY = height - sourceHeight - options.bottom;\n        }\n      } else {\n        sourceHeight = height - sourceY - (options.bottom || 0);\n      }\n\n      destWidth = sourceWidth;\n      destHeight = sourceHeight;\n    }\n\n    maxWidth = options.maxWidth;\n    maxHeight = options.maxHeight;\n    minWidth = options.minWidth;\n    minHeight = options.minHeight;\n\n    if (useCanvas && maxWidth && maxHeight && options.crop) {\n      destWidth = maxWidth;\n      destHeight = maxHeight;\n      tmp = sourceWidth / sourceHeight - maxWidth / maxHeight;\n\n      if (tmp < 0) {\n        sourceHeight = maxHeight * sourceWidth / maxWidth;\n\n        if (options.top === undefined && options.bottom === undefined) {\n          sourceY = (height - sourceHeight) / 2;\n        }\n      } else if (tmp > 0) {\n        sourceWidth = maxWidth * sourceHeight / maxHeight;\n\n        if (options.left === undefined && options.right === undefined) {\n          sourceX = (width - sourceWidth) / 2;\n        }\n      }\n    } else {\n      if (options.contain || options.cover) {\n        minWidth = maxWidth = maxWidth || minWidth;\n        minHeight = maxHeight = maxHeight || minHeight;\n      }\n\n      if (options.cover) {\n        scaleDown();\n        scaleUp();\n      } else {\n        scaleUp();\n        scaleDown();\n      }\n    }\n\n    if (useCanvas) {\n      pixelRatio = options.pixelRatio;\n\n      if (pixelRatio > 1) {\n        canvas.style.width = destWidth + 'px';\n        canvas.style.height = destHeight + 'px';\n        destWidth *= pixelRatio;\n        destHeight *= pixelRatio;\n        canvas.getContext('2d').scale(pixelRatio, pixelRatio);\n      }\n\n      downsamplingRatio = options.downsamplingRatio;\n\n      if (downsamplingRatio > 0 && downsamplingRatio < 1 && destWidth < sourceWidth && destHeight < sourceHeight) {\n        while (sourceWidth * downsamplingRatio > destWidth) {\n          canvas.width = sourceWidth * downsamplingRatio;\n          canvas.height = sourceHeight * downsamplingRatio;\n          loadImage.renderImageToCanvas(canvas, img, sourceX, sourceY, sourceWidth, sourceHeight, 0, 0, canvas.width, canvas.height);\n          sourceX = 0;\n          sourceY = 0;\n          sourceWidth = canvas.width;\n          sourceHeight = canvas.height;\n          img = document.createElement('canvas');\n          img.width = sourceWidth;\n          img.height = sourceHeight;\n          loadImage.renderImageToCanvas(img, canvas, 0, 0, sourceWidth, sourceHeight, 0, 0, sourceWidth, sourceHeight);\n        }\n      }\n\n      canvas.width = destWidth;\n      canvas.height = destHeight;\n      loadImage.transformCoordinates(canvas, options);\n      return loadImage.renderImageToCanvas(canvas, img, sourceX, sourceY, sourceWidth, sourceHeight, 0, 0, destWidth, destHeight);\n    }\n\n    img.width = destWidth;\n    img.height = destHeight;\n    return img;\n  };\n});","/*\n * JavaScript Load Image Exif Parser\n * https://github.com/blueimp/JavaScript-Load-Image\n *\n * Copyright 2013, Sebastian Tschan\n * https://blueimp.net\n *\n * Licensed under the MIT license:\n * https://opensource.org/licenses/MIT\n */\n\n/* global define, Blob */\n;\n\n(function (factory) {\n  'use strict';\n\n  if (typeof define === 'function' && define.amd) {\n    // Register as an anonymous AMD module:\n    define(['./load-image', './load-image-meta'], factory);\n  } else if (typeof module === 'object' && module.exports) {\n    factory(require('./load-image'), require('./load-image-meta'));\n  } else {\n    // Browser globals:\n    factory(window.loadImage);\n  }\n})(function (loadImage) {\n  'use strict';\n\n  loadImage.ExifMap = function () {\n    return this;\n  };\n\n  loadImage.ExifMap.prototype.map = {\n    Orientation: 0x0112\n  };\n\n  loadImage.ExifMap.prototype.get = function (id) {\n    return this[id] || this[this.map[id]];\n  };\n\n  loadImage.getExifThumbnail = function (dataView, offset, length) {\n    if (!length || offset + length > dataView.byteLength) {\n      console.log('Invalid Exif data: Invalid thumbnail data.');\n      return;\n    }\n\n    return loadImage.createObjectURL(new Blob([dataView.buffer.slice(offset, offset + length)]));\n  };\n\n  loadImage.exifTagTypes = {\n    // byte, 8-bit unsigned int:\n    1: {\n      getValue: function getValue(dataView, dataOffset) {\n        return dataView.getUint8(dataOffset);\n      },\n      size: 1\n    },\n    // ascii, 8-bit byte:\n    2: {\n      getValue: function getValue(dataView, dataOffset) {\n        return String.fromCharCode(dataView.getUint8(dataOffset));\n      },\n      size: 1,\n      ascii: true\n    },\n    // short, 16 bit int:\n    3: {\n      getValue: function getValue(dataView, dataOffset, littleEndian) {\n        return dataView.getUint16(dataOffset, littleEndian);\n      },\n      size: 2\n    },\n    // long, 32 bit int:\n    4: {\n      getValue: function getValue(dataView, dataOffset, littleEndian) {\n        return dataView.getUint32(dataOffset, littleEndian);\n      },\n      size: 4\n    },\n    // rational = two long values, first is numerator, second is denominator:\n    5: {\n      getValue: function getValue(dataView, dataOffset, littleEndian) {\n        return dataView.getUint32(dataOffset, littleEndian) / dataView.getUint32(dataOffset + 4, littleEndian);\n      },\n      size: 8\n    },\n    // slong, 32 bit signed int:\n    9: {\n      getValue: function getValue(dataView, dataOffset, littleEndian) {\n        return dataView.getInt32(dataOffset, littleEndian);\n      },\n      size: 4\n    },\n    // srational, two slongs, first is numerator, second is denominator:\n    10: {\n      getValue: function getValue(dataView, dataOffset, littleEndian) {\n        return dataView.getInt32(dataOffset, littleEndian) / dataView.getInt32(dataOffset + 4, littleEndian);\n      },\n      size: 8\n    } // undefined, 8-bit byte, value depending on field:\n\n  };\n  loadImage.exifTagTypes[7] = loadImage.exifTagTypes[1];\n\n  loadImage.getExifValue = function (dataView, tiffOffset, offset, type, length, littleEndian) {\n    var tagType = loadImage.exifTagTypes[type];\n    var tagSize;\n    var dataOffset;\n    var values;\n    var i;\n    var str;\n    var c;\n\n    if (!tagType) {\n      console.log('Invalid Exif data: Invalid tag type.');\n      return;\n    }\n\n    tagSize = tagType.size * length; // Determine if the value is contained in the dataOffset bytes,\n    // or if the value at the dataOffset is a pointer to the actual data:\n\n    dataOffset = tagSize > 4 ? tiffOffset + dataView.getUint32(offset + 8, littleEndian) : offset + 8;\n\n    if (dataOffset + tagSize > dataView.byteLength) {\n      console.log('Invalid Exif data: Invalid data offset.');\n      return;\n    }\n\n    if (length === 1) {\n      return tagType.getValue(dataView, dataOffset, littleEndian);\n    }\n\n    values = [];\n\n    for (i = 0; i < length; i += 1) {\n      values[i] = tagType.getValue(dataView, dataOffset + i * tagType.size, littleEndian);\n    }\n\n    if (tagType.ascii) {\n      str = ''; // Concatenate the chars:\n\n      for (i = 0; i < values.length; i += 1) {\n        c = values[i]; // Ignore the terminating NULL byte(s):\n\n        if (c === \"\\0\") {\n          break;\n        }\n\n        str += c;\n      }\n\n      return str;\n    }\n\n    return values;\n  };\n\n  loadImage.parseExifTag = function (dataView, tiffOffset, offset, littleEndian, data) {\n    var tag = dataView.getUint16(offset, littleEndian);\n    data.exif[tag] = loadImage.getExifValue(dataView, tiffOffset, offset, dataView.getUint16(offset + 2, littleEndian), // tag type\n    dataView.getUint32(offset + 4, littleEndian), // tag length\n    littleEndian);\n  };\n\n  loadImage.parseExifTags = function (dataView, tiffOffset, dirOffset, littleEndian, data) {\n    var tagsNumber, dirEndOffset, i;\n\n    if (dirOffset + 6 > dataView.byteLength) {\n      console.log('Invalid Exif data: Invalid directory offset.');\n      return;\n    }\n\n    tagsNumber = dataView.getUint16(dirOffset, littleEndian);\n    dirEndOffset = dirOffset + 2 + 12 * tagsNumber;\n\n    if (dirEndOffset + 4 > dataView.byteLength) {\n      console.log('Invalid Exif data: Invalid directory size.');\n      return;\n    }\n\n    for (i = 0; i < tagsNumber; i += 1) {\n      this.parseExifTag(dataView, tiffOffset, dirOffset + 2 + 12 * i, // tag offset\n      littleEndian, data);\n    } // Return the offset to the next directory:\n\n\n    return dataView.getUint32(dirEndOffset, littleEndian);\n  };\n\n  loadImage.parseExifData = function (dataView, offset, length, data, options) {\n    if (options.disableExif) {\n      return;\n    }\n\n    var tiffOffset = offset + 10;\n    var littleEndian;\n    var dirOffset;\n    var thumbnailData; // Check for the ASCII code for \"Exif\" (0x45786966):\n\n    if (dataView.getUint32(offset + 4) !== 0x45786966) {\n      // No Exif data, might be XMP data instead\n      return;\n    }\n\n    if (tiffOffset + 8 > dataView.byteLength) {\n      console.log('Invalid Exif data: Invalid segment size.');\n      return;\n    } // Check for the two null bytes:\n\n\n    if (dataView.getUint16(offset + 8) !== 0x0000) {\n      console.log('Invalid Exif data: Missing byte alignment offset.');\n      return;\n    } // Check the byte alignment:\n\n\n    switch (dataView.getUint16(tiffOffset)) {\n      case 0x4949:\n        littleEndian = true;\n        break;\n\n      case 0x4d4d:\n        littleEndian = false;\n        break;\n\n      default:\n        console.log('Invalid Exif data: Invalid byte alignment marker.');\n        return;\n    } // Check for the TIFF tag marker (0x002A):\n\n\n    if (dataView.getUint16(tiffOffset + 2, littleEndian) !== 0x002a) {\n      console.log('Invalid Exif data: Missing TIFF marker.');\n      return;\n    } // Retrieve the directory offset bytes, usually 0x00000008 or 8 decimal:\n\n\n    dirOffset = dataView.getUint32(tiffOffset + 4, littleEndian); // Create the exif object to store the tags:\n\n    data.exif = new loadImage.ExifMap(); // Parse the tags of the main image directory and retrieve the\n    // offset to the next directory, usually the thumbnail directory:\n\n    dirOffset = loadImage.parseExifTags(dataView, tiffOffset, tiffOffset + dirOffset, littleEndian, data);\n\n    if (dirOffset && !options.disableExifThumbnail) {\n      thumbnailData = {\n        exif: {}\n      };\n      dirOffset = loadImage.parseExifTags(dataView, tiffOffset, tiffOffset + dirOffset, littleEndian, thumbnailData); // Check for JPEG Thumbnail offset:\n\n      if (thumbnailData.exif[0x0201]) {\n        data.exif.Thumbnail = loadImage.getExifThumbnail(dataView, tiffOffset + thumbnailData.exif[0x0201], thumbnailData.exif[0x0202] // Thumbnail data length\n        );\n      }\n    } // Check for Exif Sub IFD Pointer:\n\n\n    if (data.exif[0x8769] && !options.disableExifSub) {\n      loadImage.parseExifTags(dataView, tiffOffset, tiffOffset + data.exif[0x8769], // directory offset\n      littleEndian, data);\n    } // Check for GPS Info IFD Pointer:\n\n\n    if (data.exif[0x8825] && !options.disableExifGps) {\n      loadImage.parseExifTags(dataView, tiffOffset, tiffOffset + data.exif[0x8825], // directory offset\n      littleEndian, data);\n    }\n  }; // Registers the Exif parser for the APP1 JPEG meta data segment:\n\n\n  loadImage.metaDataParsers.jpeg[0xffe1].push(loadImage.parseExifData); // Adds the following properties to the parseMetaData callback data:\n  // * exif: The exif tags, parsed by the parseExifData method\n  // Adds the following options to the parseMetaData method:\n  // * disableExif: Disables Exif parsing.\n  // * disableExifThumbnail: Disables parsing of the Exif Thumbnail.\n  // * disableExifSub: Disables parsing of the Exif Sub IFD.\n  // * disableExifGps: Disables parsing of the Exif GPS Info IFD.\n});","/*\n * JavaScript Load Image IPTC Parser\n * https://github.com/blueimp/JavaScript-Load-Image\n *\n * Copyright 2013, Sebastian Tschan\n * Copyright 2018, Dave Bevan\n * https://blueimp.net\n *\n * Licensed under the MIT license:\n * https://opensource.org/licenses/MIT\n */\n\n/* global define */\n;\n\n(function (factory) {\n  'use strict';\n\n  if (typeof define === 'function' && define.amd) {\n    // Register as an anonymous AMD module:\n    define(['./load-image', './load-image-meta'], factory);\n  } else if (typeof module === 'object' && module.exports) {\n    factory(require('./load-image'), require('./load-image-meta'));\n  } else {\n    // Browser globals:\n    factory(window.loadImage);\n  }\n})(function (loadImage) {\n  'use strict';\n\n  loadImage.IptcMap = function () {\n    return this;\n  };\n\n  loadImage.IptcMap.prototype.map = {\n    ObjectName: 0x5\n  };\n\n  loadImage.IptcMap.prototype.get = function (id) {\n    return this[id] || this[this.map[id]];\n  };\n\n  loadImage.parseIptcTags = function (dataView, startOffset, sectionLength, data) {\n    function getStringFromDB(buffer, start, length) {\n      var outstr = '';\n\n      for (var n = start; n < start + length; n++) {\n        outstr += String.fromCharCode(buffer.getUint8(n));\n      }\n\n      return outstr;\n    }\n\n    var fieldValue, dataSize, segmentType;\n    var segmentStartPos = startOffset;\n\n    while (segmentStartPos < startOffset + sectionLength) {\n      // we currently handle the 2: class of iptc tag\n      if (dataView.getUint8(segmentStartPos) === 0x1c && dataView.getUint8(segmentStartPos + 1) === 0x02) {\n        segmentType = dataView.getUint8(segmentStartPos + 2); // only store data for known tags\n\n        if (segmentType in data.iptc.tags) {\n          dataSize = dataView.getInt16(segmentStartPos + 3);\n          fieldValue = getStringFromDB(dataView, segmentStartPos + 5, dataSize); // Check if we already stored a value with this name\n\n          if (data.iptc.hasOwnProperty(segmentType)) {\n            // Value already stored with this name, create multivalue field\n            if (data.iptc[segmentType] instanceof Array) {\n              data.iptc[segmentType].push(fieldValue);\n            } else {\n              data.iptc[segmentType] = [data.iptc[segmentType], fieldValue];\n            }\n          } else {\n            data.iptc[segmentType] = fieldValue;\n          }\n        }\n      }\n\n      segmentStartPos++;\n    }\n  };\n\n  loadImage.parseIptcData = function (dataView, offset, length, data, options) {\n    if (options.disableIptc) {\n      return;\n    }\n\n    var markerLength = offset + length; // Found '8BIM<EOT><EOT>' ?\n\n    var isFieldSegmentStart = function isFieldSegmentStart(dataView, offset) {\n      return dataView.getUint32(offset) === 0x3842494d && dataView.getUint16(offset + 4) === 0x0404;\n    }; // Hunt forward, looking for the correct IPTC block signature:\n    // Reference: https://metacpan.org/pod/distribution/Image-MetaData-JPEG/lib/Image/MetaData/JPEG/Structures.pod#Structure-of-a-Photoshop-style-APP13-segment\n    // From https://github.com/exif-js/exif-js/blob/master/exif.js ~ line 474 on\n\n\n    while (offset + 8 < markerLength) {\n      if (isFieldSegmentStart(dataView, offset)) {\n        var nameHeaderLength = dataView.getUint8(offset + 7);\n        if (nameHeaderLength % 2 !== 0) nameHeaderLength += 1; // Check for pre photoshop 6 format\n\n        if (nameHeaderLength === 0) {\n          // Always 4\n          nameHeaderLength = 4;\n        }\n\n        var startOffset = offset + 8 + nameHeaderLength;\n\n        if (startOffset > markerLength) {\n          console.log('Invalid IPTC data: Invalid segment offset.');\n          break;\n        }\n\n        var sectionLength = dataView.getUint16(offset + 6 + nameHeaderLength);\n\n        if (offset + sectionLength > markerLength) {\n          console.log('Invalid IPTC data: Invalid segment size.');\n          break;\n        } // Create the iptc object to store the tags:\n\n\n        data.iptc = new loadImage.IptcMap(); // Parse the tags\n\n        return loadImage.parseIptcTags(dataView, startOffset, sectionLength, data);\n      }\n\n      offset++;\n    }\n\n    console.log('No IPTC data at this offset - could be XMP');\n  }; // Registers this IPTC parser for the APP13 JPEG meta data segment:\n\n\n  loadImage.metaDataParsers.jpeg[0xffed].push(loadImage.parseIptcData); // Adds the following properties to the parseMetaData callback data:\n  // * iptc: The iptc tags, parsed by the parseIptcData method\n  // Adds the following options to the parseMetaData method:\n  // * disableIptc: Disables IPTC parsing.\n});","/*\n * JavaScript Load Image Fetch\n * https://github.com/blueimp/JavaScript-Load-Image\n *\n * Copyright 2017, Sebastian Tschan\n * https://blueimp.net\n *\n * Licensed under the MIT license:\n * https://opensource.org/licenses/MIT\n */\n\n/* global define, fetch, Request */\n;\n\n(function (factory) {\n  'use strict';\n\n  if (typeof define === 'function' && define.amd) {\n    // Register as an anonymous AMD module:\n    define(['./load-image', './load-image-meta'], factory);\n  } else if (typeof module === 'object' && module.exports) {\n    factory(require('./load-image'), require('./load-image-meta'));\n  } else {\n    // Browser globals:\n    factory(window.loadImage);\n  }\n})(function (loadImage) {\n  'use strict';\n\n  if (typeof fetch !== 'undefined' && typeof Request !== 'undefined') {\n    loadImage.fetchBlob = function (url, callback, options) {\n      if (loadImage.hasMetaOption(options)) {\n        return fetch(new Request(url, options)).then(function (response) {\n          return response.blob();\n        }).then(callback).catch(function (err) {\n          console.log(err);\n          callback();\n        });\n      } else {\n        callback();\n      }\n    };\n  }\n});","/*\n * JavaScript Load Image Exif Map\n * https://github.com/blueimp/JavaScript-Load-Image\n *\n * Copyright 2013, Sebastian Tschan\n * https://blueimp.net\n *\n * Exif tags mapping based on\n * https://github.com/jseidelin/exif-js\n *\n * Licensed under the MIT license:\n * https://opensource.org/licenses/MIT\n */\n\n/* global define */\n;\n\n(function (factory) {\n  'use strict';\n\n  if (typeof define === 'function' && define.amd) {\n    // Register as an anonymous AMD module:\n    define(['./load-image', './load-image-exif'], factory);\n  } else if (typeof module === 'object' && module.exports) {\n    factory(require('./load-image'), require('./load-image-exif'));\n  } else {\n    // Browser globals:\n    factory(window.loadImage);\n  }\n})(function (loadImage) {\n  'use strict';\n\n  loadImage.ExifMap.prototype.tags = {\n    // =================\n    // TIFF tags (IFD0):\n    // =================\n    0x0100: 'ImageWidth',\n    0x0101: 'ImageHeight',\n    0x8769: 'ExifIFDPointer',\n    0x8825: 'GPSInfoIFDPointer',\n    0xa005: 'InteroperabilityIFDPointer',\n    0x0102: 'BitsPerSample',\n    0x0103: 'Compression',\n    0x0106: 'PhotometricInterpretation',\n    0x0112: 'Orientation',\n    0x0115: 'SamplesPerPixel',\n    0x011c: 'PlanarConfiguration',\n    0x0212: 'YCbCrSubSampling',\n    0x0213: 'YCbCrPositioning',\n    0x011a: 'XResolution',\n    0x011b: 'YResolution',\n    0x0128: 'ResolutionUnit',\n    0x0111: 'StripOffsets',\n    0x0116: 'RowsPerStrip',\n    0x0117: 'StripByteCounts',\n    0x0201: 'JPEGInterchangeFormat',\n    0x0202: 'JPEGInterchangeFormatLength',\n    0x012d: 'TransferFunction',\n    0x013e: 'WhitePoint',\n    0x013f: 'PrimaryChromaticities',\n    0x0211: 'YCbCrCoefficients',\n    0x0214: 'ReferenceBlackWhite',\n    0x0132: 'DateTime',\n    0x010e: 'ImageDescription',\n    0x010f: 'Make',\n    0x0110: 'Model',\n    0x0131: 'Software',\n    0x013b: 'Artist',\n    0x8298: 'Copyright',\n    // ==================\n    // Exif Sub IFD tags:\n    // ==================\n    0x9000: 'ExifVersion',\n    // EXIF version\n    0xa000: 'FlashpixVersion',\n    // Flashpix format version\n    0xa001: 'ColorSpace',\n    // Color space information tag\n    0xa002: 'PixelXDimension',\n    // Valid width of meaningful image\n    0xa003: 'PixelYDimension',\n    // Valid height of meaningful image\n    0xa500: 'Gamma',\n    0x9101: 'ComponentsConfiguration',\n    // Information about channels\n    0x9102: 'CompressedBitsPerPixel',\n    // Compressed bits per pixel\n    0x927c: 'MakerNote',\n    // Any desired information written by the manufacturer\n    0x9286: 'UserComment',\n    // Comments by user\n    0xa004: 'RelatedSoundFile',\n    // Name of related sound file\n    0x9003: 'DateTimeOriginal',\n    // Date and time when the original image was generated\n    0x9004: 'DateTimeDigitized',\n    // Date and time when the image was stored digitally\n    0x9290: 'SubSecTime',\n    // Fractions of seconds for DateTime\n    0x9291: 'SubSecTimeOriginal',\n    // Fractions of seconds for DateTimeOriginal\n    0x9292: 'SubSecTimeDigitized',\n    // Fractions of seconds for DateTimeDigitized\n    0x829a: 'ExposureTime',\n    // Exposure time (in seconds)\n    0x829d: 'FNumber',\n    0x8822: 'ExposureProgram',\n    // Exposure program\n    0x8824: 'SpectralSensitivity',\n    // Spectral sensitivity\n    0x8827: 'PhotographicSensitivity',\n    // EXIF 2.3, ISOSpeedRatings in EXIF 2.2\n    0x8828: 'OECF',\n    // Optoelectric conversion factor\n    0x8830: 'SensitivityType',\n    0x8831: 'StandardOutputSensitivity',\n    0x8832: 'RecommendedExposureIndex',\n    0x8833: 'ISOSpeed',\n    0x8834: 'ISOSpeedLatitudeyyy',\n    0x8835: 'ISOSpeedLatitudezzz',\n    0x9201: 'ShutterSpeedValue',\n    // Shutter speed\n    0x9202: 'ApertureValue',\n    // Lens aperture\n    0x9203: 'BrightnessValue',\n    // Value of brightness\n    0x9204: 'ExposureBias',\n    // Exposure bias\n    0x9205: 'MaxApertureValue',\n    // Smallest F number of lens\n    0x9206: 'SubjectDistance',\n    // Distance to subject in meters\n    0x9207: 'MeteringMode',\n    // Metering mode\n    0x9208: 'LightSource',\n    // Kind of light source\n    0x9209: 'Flash',\n    // Flash status\n    0x9214: 'SubjectArea',\n    // Location and area of main subject\n    0x920a: 'FocalLength',\n    // Focal length of the lens in mm\n    0xa20b: 'FlashEnergy',\n    // Strobe energy in BCPS\n    0xa20c: 'SpatialFrequencyResponse',\n    0xa20e: 'FocalPlaneXResolution',\n    // Number of pixels in width direction per FPRUnit\n    0xa20f: 'FocalPlaneYResolution',\n    // Number of pixels in height direction per FPRUnit\n    0xa210: 'FocalPlaneResolutionUnit',\n    // Unit for measuring the focal plane resolution\n    0xa214: 'SubjectLocation',\n    // Location of subject in image\n    0xa215: 'ExposureIndex',\n    // Exposure index selected on camera\n    0xa217: 'SensingMethod',\n    // Image sensor type\n    0xa300: 'FileSource',\n    // Image source (3 == DSC)\n    0xa301: 'SceneType',\n    // Scene type (1 == directly photographed)\n    0xa302: 'CFAPattern',\n    // Color filter array geometric pattern\n    0xa401: 'CustomRendered',\n    // Special processing\n    0xa402: 'ExposureMode',\n    // Exposure mode\n    0xa403: 'WhiteBalance',\n    // 1 = auto white balance, 2 = manual\n    0xa404: 'DigitalZoomRatio',\n    // Digital zoom ratio\n    0xa405: 'FocalLengthIn35mmFilm',\n    0xa406: 'SceneCaptureType',\n    // Type of scene\n    0xa407: 'GainControl',\n    // Degree of overall image gain adjustment\n    0xa408: 'Contrast',\n    // Direction of contrast processing applied by camera\n    0xa409: 'Saturation',\n    // Direction of saturation processing applied by camera\n    0xa40a: 'Sharpness',\n    // Direction of sharpness processing applied by camera\n    0xa40b: 'DeviceSettingDescription',\n    0xa40c: 'SubjectDistanceRange',\n    // Distance to subject\n    0xa420: 'ImageUniqueID',\n    // Identifier assigned uniquely to each image\n    0xa430: 'CameraOwnerName',\n    0xa431: 'BodySerialNumber',\n    0xa432: 'LensSpecification',\n    0xa433: 'LensMake',\n    0xa434: 'LensModel',\n    0xa435: 'LensSerialNumber',\n    // ==============\n    // GPS Info tags:\n    // ==============\n    0x0000: 'GPSVersionID',\n    0x0001: 'GPSLatitudeRef',\n    0x0002: 'GPSLatitude',\n    0x0003: 'GPSLongitudeRef',\n    0x0004: 'GPSLongitude',\n    0x0005: 'GPSAltitudeRef',\n    0x0006: 'GPSAltitude',\n    0x0007: 'GPSTimeStamp',\n    0x0008: 'GPSSatellites',\n    0x0009: 'GPSStatus',\n    0x000a: 'GPSMeasureMode',\n    0x000b: 'GPSDOP',\n    0x000c: 'GPSSpeedRef',\n    0x000d: 'GPSSpeed',\n    0x000e: 'GPSTrackRef',\n    0x000f: 'GPSTrack',\n    0x0010: 'GPSImgDirectionRef',\n    0x0011: 'GPSImgDirection',\n    0x0012: 'GPSMapDatum',\n    0x0013: 'GPSDestLatitudeRef',\n    0x0014: 'GPSDestLatitude',\n    0x0015: 'GPSDestLongitudeRef',\n    0x0016: 'GPSDestLongitude',\n    0x0017: 'GPSDestBearingRef',\n    0x0018: 'GPSDestBearing',\n    0x0019: 'GPSDestDistanceRef',\n    0x001a: 'GPSDestDistance',\n    0x001b: 'GPSProcessingMethod',\n    0x001c: 'GPSAreaInformation',\n    0x001d: 'GPSDateStamp',\n    0x001e: 'GPSDifferential',\n    0x001f: 'GPSHPositioningError'\n  };\n  loadImage.ExifMap.prototype.stringValues = {\n    ExposureProgram: {\n      0: 'Undefined',\n      1: 'Manual',\n      2: 'Normal program',\n      3: 'Aperture priority',\n      4: 'Shutter priority',\n      5: 'Creative program',\n      6: 'Action program',\n      7: 'Portrait mode',\n      8: 'Landscape mode'\n    },\n    MeteringMode: {\n      0: 'Unknown',\n      1: 'Average',\n      2: 'CenterWeightedAverage',\n      3: 'Spot',\n      4: 'MultiSpot',\n      5: 'Pattern',\n      6: 'Partial',\n      255: 'Other'\n    },\n    LightSource: {\n      0: 'Unknown',\n      1: 'Daylight',\n      2: 'Fluorescent',\n      3: 'Tungsten (incandescent light)',\n      4: 'Flash',\n      9: 'Fine weather',\n      10: 'Cloudy weather',\n      11: 'Shade',\n      12: 'Daylight fluorescent (D 5700 - 7100K)',\n      13: 'Day white fluorescent (N 4600 - 5400K)',\n      14: 'Cool white fluorescent (W 3900 - 4500K)',\n      15: 'White fluorescent (WW 3200 - 3700K)',\n      17: 'Standard light A',\n      18: 'Standard light B',\n      19: 'Standard light C',\n      20: 'D55',\n      21: 'D65',\n      22: 'D75',\n      23: 'D50',\n      24: 'ISO studio tungsten',\n      255: 'Other'\n    },\n    Flash: {\n      0x0000: 'Flash did not fire',\n      0x0001: 'Flash fired',\n      0x0005: 'Strobe return light not detected',\n      0x0007: 'Strobe return light detected',\n      0x0009: 'Flash fired, compulsory flash mode',\n      0x000d: 'Flash fired, compulsory flash mode, return light not detected',\n      0x000f: 'Flash fired, compulsory flash mode, return light detected',\n      0x0010: 'Flash did not fire, compulsory flash mode',\n      0x0018: 'Flash did not fire, auto mode',\n      0x0019: 'Flash fired, auto mode',\n      0x001d: 'Flash fired, auto mode, return light not detected',\n      0x001f: 'Flash fired, auto mode, return light detected',\n      0x0020: 'No flash function',\n      0x0041: 'Flash fired, red-eye reduction mode',\n      0x0045: 'Flash fired, red-eye reduction mode, return light not detected',\n      0x0047: 'Flash fired, red-eye reduction mode, return light detected',\n      0x0049: 'Flash fired, compulsory flash mode, red-eye reduction mode',\n      0x004d: 'Flash fired, compulsory flash mode, red-eye reduction mode, return light not detected',\n      0x004f: 'Flash fired, compulsory flash mode, red-eye reduction mode, return light detected',\n      0x0059: 'Flash fired, auto mode, red-eye reduction mode',\n      0x005d: 'Flash fired, auto mode, return light not detected, red-eye reduction mode',\n      0x005f: 'Flash fired, auto mode, return light detected, red-eye reduction mode'\n    },\n    SensingMethod: {\n      1: 'Undefined',\n      2: 'One-chip color area sensor',\n      3: 'Two-chip color area sensor',\n      4: 'Three-chip color area sensor',\n      5: 'Color sequential area sensor',\n      7: 'Trilinear sensor',\n      8: 'Color sequential linear sensor'\n    },\n    SceneCaptureType: {\n      0: 'Standard',\n      1: 'Landscape',\n      2: 'Portrait',\n      3: 'Night scene'\n    },\n    SceneType: {\n      1: 'Directly photographed'\n    },\n    CustomRendered: {\n      0: 'Normal process',\n      1: 'Custom process'\n    },\n    WhiteBalance: {\n      0: 'Auto white balance',\n      1: 'Manual white balance'\n    },\n    GainControl: {\n      0: 'None',\n      1: 'Low gain up',\n      2: 'High gain up',\n      3: 'Low gain down',\n      4: 'High gain down'\n    },\n    Contrast: {\n      0: 'Normal',\n      1: 'Soft',\n      2: 'Hard'\n    },\n    Saturation: {\n      0: 'Normal',\n      1: 'Low saturation',\n      2: 'High saturation'\n    },\n    Sharpness: {\n      0: 'Normal',\n      1: 'Soft',\n      2: 'Hard'\n    },\n    SubjectDistanceRange: {\n      0: 'Unknown',\n      1: 'Macro',\n      2: 'Close view',\n      3: 'Distant view'\n    },\n    FileSource: {\n      3: 'DSC'\n    },\n    ComponentsConfiguration: {\n      0: '',\n      1: 'Y',\n      2: 'Cb',\n      3: 'Cr',\n      4: 'R',\n      5: 'G',\n      6: 'B'\n    },\n    Orientation: {\n      1: 'top-left',\n      2: 'top-right',\n      3: 'bottom-right',\n      4: 'bottom-left',\n      5: 'left-top',\n      6: 'right-top',\n      7: 'right-bottom',\n      8: 'left-bottom'\n    }\n  };\n\n  loadImage.ExifMap.prototype.getText = function (id) {\n    var value = this.get(id);\n\n    switch (id) {\n      case 'LightSource':\n      case 'Flash':\n      case 'MeteringMode':\n      case 'ExposureProgram':\n      case 'SensingMethod':\n      case 'SceneCaptureType':\n      case 'SceneType':\n      case 'CustomRendered':\n      case 'WhiteBalance':\n      case 'GainControl':\n      case 'Contrast':\n      case 'Saturation':\n      case 'Sharpness':\n      case 'SubjectDistanceRange':\n      case 'FileSource':\n      case 'Orientation':\n        return this.stringValues[id][value];\n\n      case 'ExifVersion':\n      case 'FlashpixVersion':\n        if (!value) return;\n        return String.fromCharCode(value[0], value[1], value[2], value[3]);\n\n      case 'ComponentsConfiguration':\n        if (!value) return;\n        return this.stringValues[id][value[0]] + this.stringValues[id][value[1]] + this.stringValues[id][value[2]] + this.stringValues[id][value[3]];\n\n      case 'GPSVersionID':\n        if (!value) return;\n        return value[0] + '.' + value[1] + '.' + value[2] + '.' + value[3];\n    }\n\n    return String(value);\n  };\n\n  (function (exifMapPrototype) {\n    var tags = exifMapPrototype.tags;\n    var map = exifMapPrototype.map;\n    var prop; // Map the tag names to tags:\n\n    for (prop in tags) {\n      if (tags.hasOwnProperty(prop)) {\n        map[tags[prop]] = prop;\n      }\n    }\n  })(loadImage.ExifMap.prototype);\n\n  loadImage.ExifMap.prototype.getAll = function () {\n    var map = {};\n    var prop;\n    var id;\n\n    for (prop in this) {\n      if (this.hasOwnProperty(prop)) {\n        id = this.tags[prop];\n\n        if (id) {\n          map[id] = this.getText(id);\n        }\n      }\n    }\n\n    return map;\n  };\n});","/*\n * JavaScript Load Image IPTC Map\n * https://github.com/blueimp/JavaScript-Load-Image\n *\n * Copyright 2013, Sebastian Tschan\n * Copyright 2018, Dave Bevan\n *\n * IPTC tags mapping based on\n * https://github.com/jseidelin/exif-js\n * https://iptc.org/standards/photo-metadata\n * http://www.iptc.org/std/IIM/4.1/specification/IIMV4.1.pdf\n *\n * Licensed under the MIT license:\n * https://opensource.org/licenses/MIT\n */\n\n/* global define */\n;\n\n(function (factory) {\n  'use strict';\n\n  if (typeof define === 'function' && define.amd) {\n    // Register as an anonymous AMD module:\n    define(['./load-image', './load-image-iptc'], factory);\n  } else if (typeof module === 'object' && module.exports) {\n    factory(require('./load-image'), require('./load-image-iptc'));\n  } else {\n    // Browser globals:\n    factory(window.loadImage);\n  }\n})(function (loadImage) {\n  'use strict';\n\n  loadImage.IptcMap.prototype.tags = {\n    // ==========\n    // IPTC tags:\n    // ==========\n    0x03: 'ObjectType',\n    0x04: 'ObjectAttribute',\n    0x05: 'ObjectName',\n    0x07: 'EditStatus',\n    0x08: 'EditorialUpdate',\n    0x0a: 'Urgency',\n    0x0c: 'SubjectRef',\n    0x0f: 'Category',\n    0x14: 'SupplCategory',\n    0x16: 'FixtureID',\n    0x19: 'Keywords',\n    0x1a: 'ContentLocCode',\n    0x1b: 'ContentLocName',\n    0x1e: 'ReleaseDate',\n    0x23: 'ReleaseTime',\n    0x25: 'ExpirationDate',\n    0x26: 'ExpirationTime',\n    0x28: 'SpecialInstructions',\n    0x2a: 'ActionAdvised',\n    0x2d: 'RefService',\n    0x2f: 'RefDate',\n    0x32: 'RefNumber',\n    0x37: 'DateCreated',\n    0x3c: 'TimeCreated',\n    0x3e: 'DigitalCreationDate',\n    0x3f: 'DigitalCreationTime',\n    0x41: 'OriginatingProgram',\n    0x46: 'ProgramVersion',\n    0x4b: 'ObjectCycle',\n    0x50: 'Byline',\n    0x55: 'BylineTitle',\n    0x5a: 'City',\n    0x5c: 'Sublocation',\n    0x5f: 'State',\n    0x64: 'CountryCode',\n    0x65: 'CountryName',\n    0x67: 'OrigTransRef',\n    0x69: 'Headline',\n    0x6e: 'Credit',\n    0x73: 'Source',\n    0x74: 'CopyrightNotice',\n    0x76: 'Contact',\n    0x78: 'Caption',\n    0x7a: 'WriterEditor',\n    0x82: 'ImageType',\n    0x83: 'ImageOrientation',\n    0x87: 'LanguageID' // We don't record these tags:\n    //\n    // 0x00: 'RecordVersion',\n    // 0x7d: 'RasterizedCaption',\n    // 0x96: 'AudioType',\n    // 0x97: 'AudioSamplingRate',\n    // 0x98: 'AudioSamplingRes',\n    // 0x99: 'AudioDuration',\n    // 0x9a: 'AudioOutcue',\n    // 0xc8: 'PreviewFileFormat',\n    // 0xc9: 'PreviewFileFormatVer',\n    // 0xca: 'PreviewData'\n\n  };\n\n  loadImage.IptcMap.prototype.getText = function (id) {\n    var value = this.get(id);\n    return String(value);\n  };\n\n  (function (iptcMapPrototype) {\n    var tags = iptcMapPrototype.tags;\n    var map = iptcMapPrototype.map || {};\n    var prop; // Map the tag names to tags:\n\n    for (prop in tags) {\n      if (tags.hasOwnProperty(prop)) {\n        map[tags[prop]] = prop;\n      }\n    }\n  })(loadImage.IptcMap.prototype);\n\n  loadImage.IptcMap.prototype.getAll = function () {\n    var map = {};\n    var prop;\n    var id;\n\n    for (prop in this) {\n      if (this.hasOwnProperty(prop)) {\n        id = this.tags[prop];\n\n        if (id) {\n          map[id] = this.getText(id);\n        }\n      }\n    }\n\n    return map;\n  };\n});","/*\n * JavaScript Load Image Orientation\n * https://github.com/blueimp/JavaScript-Load-Image\n *\n * Copyright 2013, Sebastian Tschan\n * https://blueimp.net\n *\n * Licensed under the MIT license:\n * https://opensource.org/licenses/MIT\n */\n\n/* global define */\n;\n\n(function (factory) {\n  'use strict';\n\n  if (typeof define === 'function' && define.amd) {\n    // Register as an anonymous AMD module:\n    define(['./load-image', './load-image-scale', './load-image-meta'], factory);\n  } else if (typeof module === 'object' && module.exports) {\n    factory(require('./load-image'), require('./load-image-scale'), require('./load-image-meta'));\n  } else {\n    // Browser globals:\n    factory(window.loadImage);\n  }\n})(function (loadImage) {\n  'use strict';\n\n  var originalHasCanvasOption = loadImage.hasCanvasOption;\n  var originalHasMetaOption = loadImage.hasMetaOption;\n  var originalTransformCoordinates = loadImage.transformCoordinates;\n  var originalGetTransformedOptions = loadImage.getTransformedOptions; // Determines if the target image should be a canvas element:\n\n  loadImage.hasCanvasOption = function (options) {\n    return !!options.orientation || originalHasCanvasOption.call(loadImage, options);\n  }; // Determines if meta data should be loaded automatically:\n\n\n  loadImage.hasMetaOption = function (options) {\n    return options && options.orientation === true || originalHasMetaOption.call(loadImage, options);\n  }; // Transform image orientation based on\n  // the given EXIF orientation option:\n\n\n  loadImage.transformCoordinates = function (canvas, options) {\n    originalTransformCoordinates.call(loadImage, canvas, options);\n    var ctx = canvas.getContext('2d');\n    var width = canvas.width;\n    var height = canvas.height;\n    var styleWidth = canvas.style.width;\n    var styleHeight = canvas.style.height;\n    var orientation = options.orientation;\n\n    if (!orientation || orientation > 8) {\n      return;\n    }\n\n    if (orientation > 4) {\n      canvas.width = height;\n      canvas.height = width;\n      canvas.style.width = styleHeight;\n      canvas.style.height = styleWidth;\n    }\n\n    switch (orientation) {\n      case 2:\n        // horizontal flip\n        ctx.translate(width, 0);\n        ctx.scale(-1, 1);\n        break;\n\n      case 3:\n        // 180Â° rotate left\n        ctx.translate(width, height);\n        ctx.rotate(Math.PI);\n        break;\n\n      case 4:\n        // vertical flip\n        ctx.translate(0, height);\n        ctx.scale(1, -1);\n        break;\n\n      case 5:\n        // vertical flip + 90 rotate right\n        ctx.rotate(0.5 * Math.PI);\n        ctx.scale(1, -1);\n        break;\n\n      case 6:\n        // 90Â° rotate right\n        ctx.rotate(0.5 * Math.PI);\n        ctx.translate(0, -height);\n        break;\n\n      case 7:\n        // horizontal flip + 90 rotate right\n        ctx.rotate(0.5 * Math.PI);\n        ctx.translate(width, -height);\n        ctx.scale(-1, 1);\n        break;\n\n      case 8:\n        // 90Â° rotate left\n        ctx.rotate(-0.5 * Math.PI);\n        ctx.translate(-width, 0);\n        break;\n    }\n  }; // Transforms coordinate and dimension options\n  // based on the given orientation option:\n\n\n  loadImage.getTransformedOptions = function (img, opts, data) {\n    var options = originalGetTransformedOptions.call(loadImage, img, opts);\n    var orientation = options.orientation;\n    var newOptions;\n    var i;\n\n    if (orientation === true && data && data.exif) {\n      orientation = data.exif.get('Orientation');\n    }\n\n    if (!orientation || orientation > 8 || orientation === 1) {\n      return options;\n    }\n\n    newOptions = {};\n\n    for (i in options) {\n      if (options.hasOwnProperty(i)) {\n        newOptions[i] = options[i];\n      }\n    }\n\n    newOptions.orientation = orientation;\n\n    switch (orientation) {\n      case 2:\n        // horizontal flip\n        newOptions.left = options.right;\n        newOptions.right = options.left;\n        break;\n\n      case 3:\n        // 180Â° rotate left\n        newOptions.left = options.right;\n        newOptions.top = options.bottom;\n        newOptions.right = options.left;\n        newOptions.bottom = options.top;\n        break;\n\n      case 4:\n        // vertical flip\n        newOptions.top = options.bottom;\n        newOptions.bottom = options.top;\n        break;\n\n      case 5:\n        // vertical flip + 90 rotate right\n        newOptions.left = options.top;\n        newOptions.top = options.left;\n        newOptions.right = options.bottom;\n        newOptions.bottom = options.right;\n        break;\n\n      case 6:\n        // 90Â° rotate right\n        newOptions.left = options.top;\n        newOptions.top = options.right;\n        newOptions.right = options.bottom;\n        newOptions.bottom = options.left;\n        break;\n\n      case 7:\n        // horizontal flip + 90 rotate right\n        newOptions.left = options.bottom;\n        newOptions.top = options.right;\n        newOptions.right = options.top;\n        newOptions.bottom = options.left;\n        break;\n\n      case 8:\n        // 90Â° rotate left\n        newOptions.left = options.bottom;\n        newOptions.top = options.left;\n        newOptions.right = options.top;\n        newOptions.bottom = options.right;\n        break;\n    }\n\n    if (newOptions.orientation > 4) {\n      newOptions.maxWidth = options.maxHeight;\n      newOptions.maxHeight = options.maxWidth;\n      newOptions.minWidth = options.minHeight;\n      newOptions.minHeight = options.minWidth;\n      newOptions.sourceWidth = options.sourceHeight;\n      newOptions.sourceHeight = options.sourceWidth;\n    }\n\n    return newOptions;\n  };\n});","module.exports = require('./load-image');\n\nrequire('./load-image-scale');\n\nrequire('./load-image-meta');\n\nrequire('./load-image-fetch');\n\nrequire('./load-image-exif');\n\nrequire('./load-image-exif-map');\n\nrequire('./load-image-iptc');\n\nrequire('./load-image-iptc-map');\n\nrequire('./load-image-orientation');"],"sourceRoot":""}